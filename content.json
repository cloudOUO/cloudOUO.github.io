{"meta":{"title":"庭树","subtitle":"阿Qの博客","description":"大抵知心有一庭树,亭亭一如你风致","author":"阿Q","url":"https://cloudouo.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://cloudouo.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2022-07-16T14:10:56.000Z","updated":"2022-07-16T14:10:37.684Z","comments":false,"path":"about/index.html","permalink":"https://cloudouo.github.io/about/index.html","excerpt":"","text":"庭树の根“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我微信号：windyOv0 QQ：2228267960 （嘀嘀~，麻烦让一下，我要开车了！） 座右铭：极光会有的，并肩于雪山之巅"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"https://cloudouo.github.io/archives/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://cloudouo.github.io/comments/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://cloudouo.github.io/music/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://cloudouo.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://cloudouo.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-07-17T16:10:16.669Z","updated":"2022-07-17T16:10:16.669Z","comments":false,"path":"List/gallery/index.html","permalink":"https://cloudouo.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 鬼刀 s"},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-26T07:32:29.746Z","comments":false,"path":"List/movies/index.html","permalink":"https://cloudouo.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"Music-BBOX","date":"2022-07-16T04:58:56.000Z","updated":"2022-07-16T13:27:18.244Z","comments":false,"path":"List/music/index.html","permalink":"https://cloudouo.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://cloudouo.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"推箱子","slug":"02-推箱子","date":"2022-07-18T13:00:00.000Z","updated":"2022-09-01T03:58:00.000Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://cloudouo.github.io/posts/1.html","excerpt":"","text":"推箱子// PushBox.cpp : 定义控制台应用程序的入口点。 // #include \"stdafx.h\" #include &lt;iostream&gt; #include &lt;windows.h&gt; using namespace std; #define KEY_DOWN(vk_code) ((GetAsyncKeyState(vk_code)&amp;0x8000)?1:0) //#define VK_A 0x41 void gotoxy(short x, short y) { COORD pos = { x, y }; HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(hOut, pos); } int arrMap[15][15] = { { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 } }; //枚举 //枚举命名：E_哪个模块的内容_代表的含义 //常量-&gt;用全部大写来命名 //如果枚举常量没有进行赋值，默认从0开始赋值，依次递增 //如果枚举常量有赋值，从赋值的数开始，依次递增 enum { E_MENU_START, E_MENU_SET, E_MENU_EXIT }; enum { E_GAME_MENU, E_GAME_MAP, E_GAME_PASS }; //结构体：类似于类 //结构体用于数据的捆绑 //结构体是用户自定义类型 struct SBlock { int nRow; int nCol; int nRowBk; int nColBk; }; //把之前的每个步骤都记录住 //1.玩家的移动 //2.箱子移动 struct SData { int nPlayerRow; int nPlayerCol; SBlock arrBoxData[3]; }; int _tmain(int argc, _TCHAR* argv[]) { //游戏的本质：是一个大的死循环 //定义一个int型的变量 int nMenuState = E_MENU_START; //定义一个变量代表不同的游戏场景 int nGameState = E_GAME_MENU; //对象 SBlock player; //有行有列的地图 //玩家在第几行第几列 player.nRow = 5; player.nCol = 5; //定义两个变量，用于记录玩家的位置 player.nRowBk = 0; player.nColBk = 0; //定义一个数组，用来存放三个箱子 SBlock arrBox[3]; //给三个箱子初始的行列 arrBox[0].nRow = 5; arrBox[0].nCol = 6; arrBox[1].nRow = 7; arrBox[1].nCol = 8; arrBox[2].nRow = 9; arrBox[2].nCol = 9; //有一个数组用于保存三个坑的位置 SBlock arrHole[3]; arrHole[0].nRow = 4; arrHole[0].nCol = 6; arrHole[1].nRow = 6; arrHole[1].nCol = 8; arrHole[2].nRow = 8; arrHole[2].nCol = 9; //定义一个变量，用来记录玩家推的箱子的序号（索引） int nIndex = 0; //定义一个数组把所有的步骤都存储起来 SData arrData[100]; //还需要有一个变量记录当前走了多少步 int nLength = 0; while (true) { //system(\"pause\"); //系统清屏 //system(\"cls\"); //菜单-&gt;游戏场景 if (E_GAME_MENU == nGameState) { //数据更新 //一定要保证数据先行 if (KEY_DOWN(VK_UP)) { nMenuState--; if (nMenuState &lt; E_MENU_START) { //此时箭头在游戏开始之上 //设置成游戏退出即可 nMenuState = E_MENU_EXIT; } } else if (KEY_DOWN(VK_DOWN)) { nMenuState++; if (nMenuState &gt; E_MENU_EXIT) { nMenuState = E_MENU_START; } } else if (KEY_DOWN(VK_RETURN)) { if (E_MENU_START == nMenuState) { nGameState = E_GAME_MAP; } else if (E_MENU_SET == nMenuState) { } else if (E_MENU_EXIT == nMenuState) { return 0; } } //画-&gt;渲染 if (E_MENU_START == nMenuState) { cout &lt;&lt; \"■■■■■■■■■■■\" &lt;&lt; endl; cout &lt;&lt; \"■ 游 戏 菜 单 ■\" &lt;&lt; endl; cout &lt;&lt; \"■ -&gt; 游戏开始 ■\" &lt;&lt; endl; cout &lt;&lt; \"■ 游戏设置 ■\" &lt;&lt; endl; cout &lt;&lt; \"■ 游戏退出 ■\" &lt;&lt; endl; cout &lt;&lt; \"■■■■■■■■■■■\" &lt;&lt; endl; } else if (E_MENU_SET == nMenuState) { cout &lt;&lt; \"■■■■■■■■■■■\" &lt;&lt; endl; cout &lt;&lt; \"■ 游 戏 菜 单 ■\" &lt;&lt; endl; cout &lt;&lt; \"■ 游戏开始 ■\" &lt;&lt; endl; cout &lt;&lt; \"■ -&gt; 游戏设置 ■\" &lt;&lt; endl; cout &lt;&lt; \"■ 游戏退出 ■\" &lt;&lt; endl; cout &lt;&lt; \"■■■■■■■■■■■\" &lt;&lt; endl; } else if (E_MENU_EXIT == nMenuState) { cout &lt;&lt; \"■■■■■■■■■■■\" &lt;&lt; endl; cout &lt;&lt; \"■ 游 戏 菜 单 ■\" &lt;&lt; endl; cout &lt;&lt; \"■ 游戏开始 ■\" &lt;&lt; endl; cout &lt;&lt; \"■ 游戏设置 ■\" &lt;&lt; endl; cout &lt;&lt; \"■ -&gt; 游戏退出 ■\" &lt;&lt; endl; cout &lt;&lt; \"■■■■■■■■■■■\" &lt;&lt; endl; } } else if (E_GAME_MAP == nGameState) { //游戏场景 bool bESC = false; if (KEY_DOWN(VK_ESCAPE)) { nGameState = E_GAME_MENU; bESC = true; } //玩家移动之前把坐标备份起来 //赋值 player.nRowBk = player.nRow; player.nColBk = player.nCol; //备份三个箱子的坐标 for (int i = 0; i &lt; 3; i++) { arrBox[i].nRowBk = arrBox[i].nRow; arrBox[i].nColBk = arrBox[i].nCol; } if (KEY_DOWN(VK_BACK)) { //把之前记录住的数据返回回去即可 player.nRow = arrData[nLength - 1].nPlayerRow; player.nCol = arrData[nLength - 1].nPlayerCol; for (int i = 0; i &lt; 3; i++) { arrBox[i].nRow = arrData[nLength - 1].arrBoxData[i].nRow; arrBox[i].nCol = arrData[nLength - 1].arrBoxData[i].nCol; } nLength--; } if (KEY_DOWN(VK_UP)) { //先把之前的箱子的位置，玩家的位置先记录住 arrData[nLength].nPlayerRow = player.nRow; arrData[nLength].nPlayerCol = player.nCol; for (int i = 0; i &lt; 3; i++) { arrData[nLength].arrBoxData[i].nRow = arrBox[i].nRow; arrData[nLength].arrBoxData[i].nCol = arrBox[i].nCol; } nLength++; player.nRow--; } else if (KEY_DOWN(VK_DOWN)) { //先把之前的箱子的位置，玩家的位置先记录住 arrData[nLength].nPlayerRow = player.nRow; arrData[nLength].nPlayerCol = player.nCol; for (int i = 0; i &lt; 3; i++) { arrData[nLength].arrBoxData[i].nRow = arrBox[i].nRow; arrData[nLength].arrBoxData[i].nCol = arrBox[i].nCol; } nLength++; player.nRow++; } else if (KEY_DOWN(VK_LEFT)) { //先把之前的箱子的位置，玩家的位置先记录住 arrData[nLength].nPlayerRow = player.nRow; arrData[nLength].nPlayerCol = player.nCol; for (int i = 0; i &lt; 3; i++) { arrData[nLength].arrBoxData[i].nRow = arrBox[i].nRow; arrData[nLength].arrBoxData[i].nCol = arrBox[i].nCol; } nLength++; player.nCol--; } else if (KEY_DOWN(VK_RIGHT)) { //先把之前的箱子的位置，玩家的位置先记录住 arrData[nLength].nPlayerRow = player.nRow; arrData[nLength].nPlayerCol = player.nCol; for (int i = 0; i &lt; 3; i++) { arrData[nLength].arrBoxData[i].nRow = arrBox[i].nRow; arrData[nLength].arrBoxData[i].nCol = arrBox[i].nCol; } nLength++; player.nCol++; } //移动之后判断玩家是否推到箱子 for (int i = 0; i &lt; 3; i++) { if (player.nRow == arrBox[i].nRow &amp;&amp; player.nCol == arrBox[i].nCol) { //玩家跟箱子重叠 //向量 arrBox[i].nRow += player.nRow - player.nRowBk; arrBox[i].nCol += player.nCol - player.nColBk; //此时第i个箱子就是我推的那个箱子 nIndex = i; } } //箱子移动之后判断箱子是否撞墙 if (1 == arrMap[arrBox[nIndex].nRow][arrBox[nIndex].nCol]) { //推的箱子撞墙了 arrBox[nIndex].nRow = arrBox[nIndex].nRowBk; arrBox[nIndex].nCol = arrBox[nIndex].nColBk; player.nRow = player.nRowBk; player.nCol = player.nColBk; } //箱子撞箱子：把另外两个箱子当做墙 for (int i = 0; i &lt; 3; i++) { if (nIndex != i &amp;&amp; arrBox[i].nRow == arrBox[nIndex].nRow &amp;&amp; arrBox[i].nCol == arrBox[nIndex].nCol) { arrBox[nIndex].nRow = arrBox[nIndex].nRowBk; arrBox[nIndex].nCol = arrBox[nIndex].nColBk; player.nRow = player.nRowBk; player.nCol = player.nColBk; } } //有一个变量用于统计箱子入坑的数量 int nCount = 0; //箱子入坑判断 for (int i = 0; i &lt; 3; i++)//遍历所有箱子 { for (int j = 0; j &lt; 3; j++)//遍历所有坑 { if (arrBox[i].nRow == arrHole[j].nRow &amp;&amp; arrBox[i].nCol == arrHole[j].nCol) { //某一个箱子推入到某一个坑里面 nCount++; break; } } } if (nCount == 3) { bESC = true; //游戏胜利了！ nGameState = E_GAME_PASS; } //玩家移动之后，判断是否陷入到墙里面 if (1 == arrMap[player.nRow][player.nCol]) { player.nRow = player.nRowBk; player.nCol = player.nColBk; } for (int i = 0; i &lt; 15; i++)//遍历行 { for (int j = 0; j &lt; 15; j++)//遍历列 { bool bDrawBox = false; bool bDrawFinish = false; for (int n = 0; n &lt; 3; n++) { if (i == arrBox[n].nRow &amp;&amp; j == arrBox[n].nCol) { //当前位置存在某一个箱子 //判断这一个箱子是不是在坑里面 for (int m = 0; m &lt; 3; m++)//遍历三个坑 { //判断箱子和某一个坑是否重叠 if (arrBox[n].nRow == arrHole[m].nRow &amp;&amp; arrBox[n].nCol == arrHole[m].nCol) { //当前这个箱子是被推到坑里面的 bDrawFinish = true; break; } } bDrawBox = true; break; } } bool bDrawHole = false; for (int n = 0; n &lt; 3; n++) { if (i == arrHole[n].nRow &amp;&amp; j == arrHole[n].nCol) { bDrawHole = true; break; } } if (1 == arrMap[i][j]) { cout &lt;&lt; \"■\"; } else if (bDrawFinish) { cout &lt;&lt; \"进\"; } else if (bDrawBox) { cout &lt;&lt; \"箱\"; } else if (bDrawHole) { cout &lt;&lt; \"坑\"; } else if (i == player.nRow &amp;&amp; j == player.nCol) { cout &lt;&lt; \"玩\"; } else if (0 == arrMap[i][j]) { cout &lt;&lt; \" \"; } } cout &lt;&lt; endl; } if (bESC == true) { system(\"cls\"); } } else if (E_GAME_PASS == nGameState) { cout &lt;&lt; \"游戏胜利\" &lt;&lt; endl; } gotoxy(0, 0); //让系统运行变慢 Sleep(80); } //1.整理推箱子（明天把完善之后的项目提交上来） //2.新建一个Snake的项目 //3.按键之后蛇头朝着按键的方向移动 return 0; }","categories":[{"name":"学习","slug":"学习","permalink":"https://cloudouo.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"关于博客","slug":"01-关于博客","date":"2022-07-17T11:25:00.000Z","updated":"2022-07-17T11:23:08.739Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://cloudouo.github.io/posts/1.html","excerpt":"","text":"博客初衷博主主要是用来记录学习哒，把所学东西总结复刻在博客上，可以直观的看到学习路径，方便以后整理，本博客的初衷只为学习，仅为个人使用，不做其他用途。 展望博客博主主要是对C++、游戏制作、虚幻引擎等进行学习，因此以后博主会发一些游戏制作等相关教程，希望能与大家一同进步！ 关于博主庭树，是我对心里之人的别称。把相思寄于互联网，在互联网中发芽，茁壮起来的庭树会见证我的生活，我的学习，我的人生，而我也会努力去见证庭树的一生！ 阿Q要努力实现甘梦梦的小目标呀 !😄 希望能更努力,早点拥有自己的小房子，清晨起床迎着咖啡和面包的香气，闲暇时找三五好友吃火锅喝汽，傍晚和喜欢的人陷在沙发里看剧吃零食，入眠时等满天星光吹着晚风落地。 前路仍有明月共爱河，祝大家星光璀璨，佳人相伴！","categories":[{"name":"生活","slug":"生活","permalink":"https://cloudouo.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://cloudouo.github.io/tags/%E6%83%B3%E6%B3%95/"}]}],"categories":[{"name":"学习","slug":"学习","permalink":"https://cloudouo.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"生活","slug":"生活","permalink":"https://cloudouo.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://cloudouo.github.io/tags/%E6%83%B3%E6%B3%95/"}]}